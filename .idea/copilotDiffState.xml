<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/(tabs)/index.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/(tabs)/index.tsx" />
              <option name="originalContent" value="import {ThemedText} from '@/components/ThemedText';&#10;import {ThemedView} from '@/components/ThemedView';&#10;import styles from '@/constants/style';&#10;import {Ionicons} from '@expo/vector-icons';&#10;import {useBottomTabBarHeight} from '@react-navigation/bottom-tabs';&#10;import {BlurView} from 'expo-blur';&#10;import * as DocumentPicker from 'expo-document-picker';&#10;import * as Haptics from 'expo-haptics';&#10;import {Image} from 'expo-image';&#10;import * as ImagePicker from 'expo-image-picker';&#10;import {useEffect, useRef, useState} from 'react';&#10;import {&#10;    Alert,&#10;    Animated,&#10;    Dimensions,&#10;    FlatList,&#10;    KeyboardAvoidingView,&#10;    Modal,&#10;    Platform,&#10;    Text,&#10;    TextInput,&#10;    TouchableOpacity,&#10;    TouchableWithoutFeedback,&#10;    View&#10;} from 'react-native';&#10;&#10;const {width: SCREEN_WIDTH} = Dimensions.get('window');&#10;&#10;interface AttachedFile {&#10;    id: string;&#10;    uri: string;&#10;    name: string;&#10;    type: 'image' | 'document';&#10;    size: number;&#10;    mimeType: string;&#10;}&#10;&#10;interface Message {&#10;    id: string;&#10;    text: string;&#10;    timestamp: Date;&#10;    isUser: boolean;&#10;    sender: 'You' | 'Verdora';&#10;    attachedFile?: AttachedFile;&#10;}&#10;&#10;export default function ChatScreen() {&#10;    const tabBarHeight = useBottomTabBarHeight();&#10;    const [messages, setMessages] = useState&lt;Message[]&gt;([&#10;        {&#10;            id: '1',&#10;            text: '안녕하세요! 저는 Verdora입니다. 무엇을 도와드릴까요? ',&#10;            timestamp: new Date(),&#10;            isUser: false,&#10;            sender: 'Verdora',&#10;        },&#10;    ]);&#10;    const [inputText, setInputText] = useState('');&#10;    const [attachedFile, setAttachedFile] = useState&lt;AttachedFile | null&gt;(null);&#10;    const [attachmentModalVisible, setAttachmentModalVisible] = useState(false);&#10;&#10;    const flatListRef = useRef&lt;FlatList&lt;Message&gt;&gt;(null);&#10;&#10;    useEffect(() =&gt; {&#10;        const timer = setTimeout(() =&gt; flatListRef.current?.scrollToEnd({animated: true}), 100);&#10;        return () =&gt; clearTimeout(timer); // 메모리 누수를 방지하기 위해 타이머 정리&#10;    }, [messages]);&#10;&#10;    const [isMenuVisible, setMenuVisible] = useState(false);&#10;    const slideAnim = useRef(new Animated.Value(SCREEN_WIDTH)).current;&#10;&#10;    /**&#10;     * 사이드 메뉴를 여는 함수&#10;     * 메뉴 표시 상태를 true로 설정하고 슬라이드 애니메이션을 실행합니다&#10;     */&#10;    const openMenu = () =&gt; {&#10;        setMenuVisible(true);&#10;        Animated.timing(slideAnim, {&#10;            toValue: 0,&#10;            duration: 250,&#10;            useNativeDriver: true,&#10;        }).start();&#10;    };&#10;&#10;    /**&#10;     * 사이드 메뉴를 닫는 함수&#10;     * 슬라이드 애니메이션 후 메뉴 표시 상태를 false로 설정합니다&#10;     */&#10;    const closeMenu = () =&gt; {&#10;        Animated.timing(slideAnim, {&#10;            toValue: SCREEN_WIDTH,&#10;            duration: 250,&#10;            useNativeDriver: true,&#10;        }).start(() =&gt; setMenuVisible(false));&#10;    };&#10;&#10;    /**&#10;     * Verdora AI의 응답을 생성하는 함수&#10;     * @param msg - 사용자 메시지&#10;     * @param hasFile - 파일 첨부 여부&#10;     * @returns 생성된 응답 문자열&#10;     */&#10;    const getVerdoraResponse = (msg: string, hasFile = false): string =&gt; {&#10;        if (hasFile) {&#10;            const fileResponses = [&#10;                '파일을 확인했습니다! 흥미로운 내용이네요.',&#10;                '첨부해주신 파일 감사합니다. 어떤 도움이 필요하신가요?',&#10;                '파일을 잘 받았습니다! 이것에 대해 더 자세히 알려주세요.',&#10;                '좋은 자료네요! 이와 관련해서 궁금한 점이 있으시면 언제든 물어보세요.',&#10;            ];&#10;            return fileResponses[Math.floor(Math.random() * fileResponses.length)];&#10;        }&#10;        const responses = [&#10;            '흥미로운 질문이네요! 더 자세히 설명해주시겠어요?',&#10;            '네, 이해했습니다. 다른 궁금한 것이 있으신가요?',&#10;            '좋은 생각이에요! 어떻게 도와드릴까요?',&#10;            '그렇군요! 더 많은 정보를 원하시면 언제든 말씀해주세요.',&#10;            '정말 재미있는 주제네요. 계속 이야기해보아요!',&#10;            '감사합니다! 다른 도움이 필요하시면 알려주세요.',&#10;            '네, 알겠습니다. 또 다른 질문이 있으신가요?',&#10;        ];&#10;        if (msg.includes('안녕') || msg.includes('hello')) return '안녕하세요! 좋은 하루 보내고 계신가요? ';&#10;        if (msg.includes('고마워') || msg.includes('감사')) return '천만에요! 언제든지 도와드릴게요. ';&#10;        if (msg.includes('이름') || msg.includes('누구')) return '저는 Verdora예요! AI 어시스턴트로서 여러분을 도와드리고 있어요. ✨';&#10;        return responses[Math.floor(Math.random() * responses.length)];&#10;    };&#10;&#10;    /**&#10;     * 메시지를 전송하는 함수&#10;     * 사용자 메시지를 추가하고 1초 후 AI 응답을 생성합니다&#10;     */&#10;    const sendMessage = async () =&gt; {&#10;        if (inputText.trim() || attachedFile) {&#10;            await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);&#10;            setMessages(prev =&gt; [&#10;                ...prev,&#10;                {&#10;                    id: Date.now().toString(),&#10;                    text: inputText.trim() || (attachedFile ? '파일을 첨부했습니다.' : ''),&#10;                    timestamp: new Date(),&#10;                    isUser: true,&#10;                    sender: 'You',&#10;                    attachedFile: attachedFile || undefined,&#10;                }&#10;            ]);&#10;            const msg = inputText.trim();&#10;            const hasFile = !!attachedFile;&#10;            setInputText('');&#10;            setAttachedFile(null);&#10;            setTimeout(async () =&gt; {&#10;                await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);&#10;                setMessages(prev =&gt; [&#10;                    ...prev,&#10;                    {&#10;                        id: (Date.now() + 1).toString(),&#10;                        text: getVerdoraResponse(msg, hasFile),&#10;                        timestamp: new Date(),&#10;                        isUser: false,&#10;                        sender: 'Verdora',&#10;                    }&#10;                ]);&#10;            }, 1000);&#10;        }&#10;    };&#10;&#10;    /**&#10;     * 파일 선택 결과를 처리하는 함수&#10;     * @param result - ImagePicker 또는 DocumentPicker의 결과&#10;     * @param type - 파일 타입 ('image' 또는 'document')&#10;     */&#10;    const handleFileSelection = async (result: any, type: 'image' | 'document') =&gt; {&#10;        if (!result.canceled &amp;&amp; result.assets?.length) {&#10;            const asset = result.assets[0];&#10;            if (type === 'image' || ['.txt', '.md', '.pdf'].some(ext =&gt; asset.uri.endsWith(ext))) {&#10;                setAttachedFile({&#10;                    id: Date.now().toString(),&#10;                    uri: asset.uri,&#10;                    name: asset.fileName ?? (type === 'image' ? 'image.jpg' : 'document'),&#10;                    type,&#10;                    size: asset.fileSize ?? 0,&#10;                    mimeType: asset.type ?? (type === 'image' ? 'image/jpeg' : 'application/octet-stream'),&#10;                });&#10;            } else {&#10;                console.warn('Only .txt, .md, .pdf files are allowed.');&#10;            }&#10;        }&#10;    };&#10;&#10;    /**&#10;     * 카메라로 사진을 촬영하는 함수&#10;     * 첨부 모달을 닫고 카메라를 실행합니다&#10;     */&#10;    const pickCamera = async () =&gt; {&#10;        setAttachmentModalVisible(false);&#10;        const result = await ImagePicker.launchCameraAsync({&#10;            mediaTypes: ImagePicker.MediaTypeOptions.Images,&#10;            quality: 0.8&#10;        });&#10;        await handleFileSelection(result, 'image');&#10;    };&#10;    &#10;    /**&#10;     * 갤러리에서 이미지를 선택하는 함수&#10;     * 첨부 모달을 닫고 이미지 라이브러리를 실행합니다&#10;     */&#10;    const pickGallery = async () =&gt; {&#10;        setAttachmentModalVisible(false);&#10;        const result = await ImagePicker.launchImageLibraryAsync({&#10;            mediaTypes: ImagePicker.MediaTypeOptions.Images,&#10;            quality: 0.8&#10;        });&#10;        await handleFileSelection(result, 'image');&#10;    };&#10;&#10;    /**&#10;     * 문서 파일을 선택하는 함수&#10;     * 첨부 모달을 닫고 문서 선택기를 실행합니다&#10;     */&#10;    const pickDocument = async () =&gt; {&#10;        setAttachmentModalVisible(false);&#10;        const result = await DocumentPicker.getDocumentAsync({copyToCacheDirectory: true});&#10;        await handleFileSelection(result, 'document');&#10;    };&#10;&#10;    /**&#10;     * 첨부된 파일을 제거하는 함수&#10;     * 햅틱 피드백과 함께 첨부 파일을 null로 설정합니다&#10;     */&#10;    const removeFile = async () =&gt; {&#10;        await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);&#10;        setAttachedFile(null);&#10;    };&#10;&#10;    /**&#10;     * 파일 크기를 사람이 읽기 쉬운 형태로 변환하는 함수&#10;     * @param bytes - 바이트 단위의 파일 크기&#10;     * @returns 변환된 크기 문자열 (예: &quot;1.5 MB&quot;)&#10;     */&#10;    const formatSize = (bytes: number): string =&gt; {&#10;        if (!bytes) return '0 Bytes';&#10;        const k = 1024, sizes = ['Bytes', 'KB', 'MB', 'GB'];&#10;        const i = Math.floor(Math.log(bytes) / Math.log(k));&#10;        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];&#10;    };&#10;&#10;    /**&#10;     * 앱 사용법 가이드를 표시하는 함수&#10;     * 햅틱 피드백과 함께 사용법 알림을 표시합니다&#10;     */&#10;    const showGuide = async () =&gt; {&#10;        await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);&#10;        Alert.alert('사용법', '• Verdora와 자유롭게 대화하세요\n• 질문을 입력하고 전송 버튼을 누르세요\n• + 버튼으로 파일을 첨부할 수 있습니다\n• AI가 자동으로 응답해드립니다', [{text: '확인'}]);&#10;    };&#10;&#10;    /**&#10;     * 메뉴 버튼 클릭을 처리하는 함수&#10;     * 햅틱 피드백과 함께 메뉴를 엽니다&#10;     */&#10;    const handleMenuPress = async () =&gt; {&#10;        await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);&#10;        openMenu();&#10;    };&#10;&#10;    /**&#10;     * 메뉴 항목 클릭을 처리하는 함수&#10;     * @param key - 클릭된 메뉴 항목의 키&#10;     */&#10;    const handleMenuItemPress = (key: string) =&gt; {&#10;        closeMenu();&#10;        setTimeout(() =&gt; {&#10;            switch (key) {&#10;                case 'country':&#10;                    Alert.alert('알림', '나라 설정 기능은 준비 중입니다.');&#10;                    break;&#10;                case 'language':&#10;                    Alert.alert('알림', '언어 설정 기능은 준비 중입니다.');&#10;                    break;&#10;                case 'travel':&#10;                    Alert.alert('알림', '타국 여행시 주의점 안내 기능은 준비 중입니다.');&#10;                    break;&#10;                case 'cases':&#10;                    Alert.alert('알림', '관련 사례 보기 기능은 준비 중입니다.');&#10;                    break;&#10;                case 'delete':&#10;                    Alert.alert(&#10;                        '정말 삭제하시겠습니까?',&#10;                        '모든 대화 내용이 사라지며, 복구할 수 없습니다.',&#10;                        [&#10;                            {&#10;                                text: '삭제',&#10;                                style: 'destructive',&#10;                                onPress: async () =&gt; {&#10;                                    await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning);&#10;                                    setMessages([{&#10;                                        id: '1',&#10;                                        text: '안녕하세요! 저는 Verdora입니다. 무엇을 도와드릴까요? ',&#10;                                        timestamp: new Date(),&#10;                                        isUser: false,&#10;                                        sender: 'Verdora',&#10;                                    }]);&#10;                                },&#10;                            },&#10;                            {text: '취소', style: 'cancel'},&#10;                        ]&#10;                    );&#10;                    break;&#10;            }&#10;        }, 250);&#10;    };&#10;&#10;    /**&#10;     * 사이드 메뉴를 렌더링하는 함수&#10;     * @returns 사이드 메뉴 JSX 컴포넌트&#10;     */&#10;    const renderSideMenu = () =&gt; {&#10;        const menuItems = [&#10;            {key: 'country', icon: 'globe-outline', text: '나라 설정'},&#10;            {key: 'language', icon: 'language-outline', text: '언어 설정'},&#10;            {key: 'travel', icon: 'alert-circle-outline', text: '타국 여행시 주의점'},&#10;            {key: 'cases', icon: 'book-outline', text: '관련 사례'},&#10;        ];&#10;        return (&#10;            &lt;Modal transparent visible={isMenuVisible} onRequestClose={closeMenu} animationType=&quot;fade&quot;&gt;&#10;                &lt;TouchableWithoutFeedback onPress={closeMenu}&gt;&#10;                    &lt;View style={styles.menuBackdrop}&gt;&#10;                        &lt;Animated.View style={[styles.menuDrawer, {transform: [{translateX: slideAnim}]}]}&gt;&#10;                            &lt;TouchableWithoutFeedback&gt;&#10;                                &lt;ThemedView style={{flex: 1}}&gt;&#10;                                    &lt;View style={styles.menuHeaderContainer}&gt;&#10;                                        &lt;View style={styles.logo}&gt;&#10;                                            &lt;Image style={styles.logoSize}&#10;                                                   source={require('@/assets/images/icon.png')}/&gt;&#10;                                        &lt;/View&gt;&#10;                                        &lt;ThemedText style={styles.menuHeaderTitle}&gt;Verdora&lt;/ThemedText&gt;&#10;                                    &lt;/View&gt;&#10;                                    &lt;View style={styles.menuSeparator}/&gt;&#10;                                    {menuItems.map(item =&gt; (&#10;                                        &lt;TouchableOpacity key={item.key} style={styles.menuItem}&#10;                                                          onPress={() =&gt; handleMenuItemPress(item.key)}&gt;&#10;                                            &lt;Ionicons name={item.icon as any} size={22} color=&quot;#555&quot;&#10;                                                      style={styles.menuItemIcon}/&gt;&#10;                                            &lt;ThemedText style={styles.menuItemText}&gt;{item.text}&lt;/ThemedText&gt;&#10;                                        &lt;/TouchableOpacity&gt;&#10;                                    ))}&#10;                                    &lt;View style={styles.menuFooter}&gt;&#10;                                        &lt;View style={styles.menuSeparator}/&gt;&#10;                                        &lt;TouchableOpacity style={styles.menuItem}&#10;                                                          onPress={() =&gt; handleMenuItemPress('delete')}&gt;&#10;                                            &lt;Ionicons name=&quot;trash-outline&quot; size={22} color=&quot;#ff4444&quot;&#10;                                                      style={styles.menuItemIcon}/&gt;&#10;                                            &lt;ThemedText style={[styles.menuItemText, {color: '#ff4444'}]}&gt;채팅 기록&#10;                                                삭제&lt;/ThemedText&gt;&#10;                                        &lt;/TouchableOpacity&gt;&#10;                                    &lt;/View&gt;&#10;                                &lt;/ThemedView&gt;&#10;                            &lt;/TouchableWithoutFeedback&gt;&#10;                        &lt;/Animated.View&gt;&#10;                    &lt;/View&gt;&#10;                &lt;/TouchableWithoutFeedback&gt;&#10;            &lt;/Modal&gt;&#10;        );&#10;    };&#10;&#10;    /**&#10;     * 첨부된 파일을 렌더링하는 함수&#10;     * @param file - 렌더링할 첨부 파일 객체&#10;     * @param inMsg - 메시지 내부에서 렌더링되는지 여부 (기본값: false)&#10;     * @returns 첨부 파일 JSX 컴포넌트&#10;     */&#10;    const renderAttachedFile = (file: AttachedFile, inMsg = false) =&gt; (&#10;        &lt;View style={[styles.attachedFileContainer, inMsg &amp;&amp; styles.attachedFileInMessage]}&gt;&#10;            {file.type === 'image' ? (&#10;                &lt;View style={styles.attachedImageContainer}&gt;&#10;                    &lt;Image source={{uri: file.uri}} style={styles.attachedImage} contentFit=&quot;cover&quot; transition={200}/&gt;&#10;                    {!inMsg &amp;&amp; (&#10;                        &lt;TouchableOpacity style={styles.removeFileButton} onPress={removeFile}&#10;                                          hitSlop={{top: 10, bottom: 10, left: 10, right: 10}}&gt;&#10;                            &lt;Ionicons name=&quot;close-circle&quot; size={20} color=&quot;#ff4444&quot;/&gt;&#10;                        &lt;/TouchableOpacity&gt;&#10;                    )}&#10;                &lt;/View&gt;&#10;            ) : (&#10;                &lt;View style={styles.attachedDocumentContainer}&gt;&#10;                    &lt;View style={styles.documentIconContainer}&gt;&#10;                        &lt;Ionicons name=&quot;document-text&quot; size={24} color=&quot;#666&quot;/&gt;&#10;                    &lt;/View&gt;&#10;                    &lt;View style={styles.documentInfo}&gt;&#10;                        &lt;ThemedText style={styles.documentName} numberOfLines={1}&gt;{file.name}&lt;/ThemedText&gt;&#10;                        {file.size &amp;&amp; &lt;ThemedText style={styles.documentSize}&gt;{formatSize(file.size)}&lt;/ThemedText&gt;}&#10;                    &lt;/View&gt;&#10;                    {!inMsg &amp;&amp; (&#10;                        &lt;TouchableOpacity style={styles.removeFileButton} onPress={removeFile}&#10;                                          hitSlop={{top: 10, bottom: 10, left: 10, right: 10}}&gt;&#10;                            &lt;Ionicons name=&quot;close-circle&quot; size={20} color=&quot;#ff4444&quot;/&gt;&#10;                        &lt;/TouchableOpacity&gt;&#10;                    )}&#10;                &lt;/View&gt;&#10;            )}&#10;        &lt;/View&gt;&#10;    );&#10;&#10;    /**&#10;     * 개별 메시지를 렌더링하는 함수&#10;     * @param item - 렌더링할 메시지 객체&#10;     * @returns 메시지 JSX 컴포넌트&#10;     */&#10;    const renderMessage = ({item}: { item: Message }) =&gt; (&#10;        &lt;View style={[&#10;            styles.messageWrapper,&#10;            item.isUser ? styles.userMessageWrapper : styles.aiMessageWrapper&#10;        ]}&gt;&#10;            {!item.isUser &amp;&amp; (&#10;                &lt;View style={styles.aiProfileContainer}&gt;&#10;                    &lt;View style={styles.profileImageContainer}&gt;&#10;                        &lt;View style={styles.profileImagePlaceholder}&gt;&#10;                            &lt;Image style={styles.logoSize} source={require('@/assets/images/icon.png')}/&gt;&#10;&#10;                        &lt;/View&gt;&#10;                    &lt;/View&gt;&#10;                    &lt;ThemedText style={styles.senderName}&gt;Verdora&lt;/ThemedText&gt;&#10;                &lt;/View&gt;&#10;            )}&#10;            &lt;View style={[&#10;                styles.messageContainer,&#10;                item.isUser ? styles.userMessage : styles.otherMessage&#10;            ]}&gt;&#10;                {item.attachedFile &amp;&amp; renderAttachedFile(item.attachedFile, true)}&#10;                {item.text &amp;&amp; (&#10;                    &lt;ThemedText style={[&#10;                        styles.messageText,&#10;                        item.isUser ? styles.userMessageText : styles.otherMessageText,&#10;                        item.attachedFile &amp;&amp; styles.messageTextWithFile&#10;                    ]}&gt;&#10;                        {item.text}&#10;                    &lt;/ThemedText&gt;&#10;                )}&#10;                &lt;ThemedText style={[&#10;                    styles.timestamp,&#10;                    item.isUser ? styles.userTimestamp : styles.aiTimestamp&#10;                ]}&gt;&#10;                    {item.timestamp.toLocaleTimeString('ko-KR', {hour: '2-digit', minute: '2-digit'})}&#10;                &lt;/ThemedText&gt;&#10;            &lt;/View&gt;&#10;        &lt;/View&gt;&#10;    );&#10;&#10;    return (&#10;        &lt;KeyboardAvoidingView&#10;            style={styles.container}&#10;            behavior={Platform.OS === 'ios' ? 'padding' : 'height'}&#10;            keyboardVerticalOffset={Platform.OS === 'ios' ? tabBarHeight : 0}&#10;        &gt;&#10;            &lt;BlurView intensity={0} tint=&quot;light&quot; style={styles.header}&gt;&#10;                &lt;View style={styles.headerContent}&gt;&#10;                    &lt;View style={styles.logoContainer}&gt;&#10;                        &lt;View style={styles.logo}&gt;&#10;                            &lt;Image style={styles.logoSize} source={require('@/assets/images/icon.png')}/&gt;&#10;&#10;                        &lt;/View&gt;&#10;                        &lt;ThemedText style={styles.appName}&gt;Verdora&lt;/ThemedText&gt;&#10;                    &lt;/View&gt;&#10;                    &lt;View style={styles.rightButtons}&gt;&#10;                        &lt;TouchableOpacity style={styles.guideButton} onPress={showGuide}&gt;&#10;                            &lt;ThemedText style={styles.guideButtonText}&gt;사용법&lt;/ThemedText&gt;&#10;                        &lt;/TouchableOpacity&gt;&#10;                        &lt;TouchableOpacity style={styles.hamburgerButton} onPress={handleMenuPress}&gt;&#10;                            &lt;Ionicons name=&quot;menu&quot; size={24} color=&quot;#fff&quot;/&gt;&#10;                        &lt;/TouchableOpacity&gt;&#10;                    &lt;/View&gt;&#10;                &lt;/View&gt;&#10;            &lt;/BlurView&gt;&#10;            &lt;FlatList&#10;                ref={flatListRef}&#10;                data={messages}&#10;                renderItem={renderMessage}&#10;                keyExtractor={(item) =&gt; item.id}&#10;                style={styles.messagesList}&#10;                contentContainerStyle={styles.messagesContainer}&#10;                showsVerticalScrollIndicator={false}&#10;                keyboardShouldPersistTaps=&quot;handled&quot;&#10;            /&gt;&#10;            {attachedFile &amp;&amp; (&#10;                &lt;BlurView intensity={95} tint=&quot;light&quot; style={styles.attachmentPreview}&gt;&#10;                    {renderAttachedFile(attachedFile)}&#10;                &lt;/BlurView&gt;&#10;            )}&#10;            &lt;ThemedView style={[styles.inputContainer]}&gt;&#10;                &lt;TouchableOpacity style={styles.attachButton} onPress={() =&gt; setAttachmentModalVisible(true)}&#10;                                  hitSlop={{top: 5, bottom: 5, left: 5, right: 5}}&gt;&#10;                    &lt;Ionicons name=&quot;add&quot; size={24} color=&quot;#F59A23&quot;/&gt;&#10;                &lt;/TouchableOpacity&gt;&#10;                &lt;TextInput&#10;                    style={styles.textInput}&#10;                    value={inputText}&#10;                    onChangeText={setInputText}&#10;                    placeholder=&quot;Verdora에게 메시지를 보내세요...&quot;&#10;                    placeholderTextColor=&quot;#999&quot;&#10;                    multiline&#10;                    maxLength={1000}&#10;                    returnKeyType=&quot;send&quot;&#10;                /&gt;&#10;                &lt;TouchableOpacity&#10;                    style={[styles.sendButton, {opacity: (inputText.trim() || attachedFile) ? 1 : 0.5}]}&#10;                    onPress={sendMessage}&#10;                    disabled={!inputText.trim() &amp;&amp; !attachedFile}&#10;                    hitSlop={{top: 5, bottom: 5, left: 5, right: 5}}&#10;                &gt;&#10;                    &lt;Ionicons name=&quot;send&quot; size={20} color=&quot;#fff&quot;/&gt;&#10;                &lt;/TouchableOpacity&gt;&#10;            &lt;/ThemedView&gt;&#10;            &lt;Modal&#10;                visible={attachmentModalVisible}&#10;                animationType=&quot;slide&quot;&#10;                transparent&#10;                statusBarTranslucent&#10;                onRequestClose={() =&gt; setAttachmentModalVisible(false)}&#10;            &gt;&#10;                &lt;TouchableWithoutFeedback onPress={() =&gt; setAttachmentModalVisible(false)}&gt;&#10;                    &lt;View style={styles.attachmentModalBackdrop}/&gt;&#10;                &lt;/TouchableWithoutFeedback&gt;&#10;                &lt;View style={styles.attachmentModalContainer}&gt;&#10;                    &lt;Text style={styles.attachmentModalTitle}&gt;첨부파일 선택&lt;/Text&gt;&#10;                    &lt;View style={styles.attachmentOptionsWrapper}&gt;&#10;                        &lt;TouchableOpacity style={styles.attachmentOptionButton} onPress={pickCamera}&gt;&#10;                            &lt;View style={styles.attachmentOptionIconContainer}&gt;&#10;                                &lt;Ionicons name=&quot;camera&quot; size={32} color=&quot;#F59A23&quot;/&gt;&#10;                            &lt;/View&gt;&#10;                            &lt;Text style={styles.attachmentOptionText}&gt;카메라&lt;/Text&gt;&#10;                        &lt;/TouchableOpacity&gt;&#10;                        &lt;TouchableOpacity style={styles.attachmentOptionButton} onPress={pickGallery}&gt;&#10;                            &lt;View style={styles.attachmentOptionIconContainer}&gt;&#10;                                &lt;Ionicons name=&quot;image&quot; size={32} color=&quot;#F59A23&quot;/&gt;&#10;                            &lt;/View&gt;&#10;                            &lt;Text style={styles.attachmentOptionText}&gt;갤러리&lt;/Text&gt;&#10;                        &lt;/TouchableOpacity&gt;&#10;                        &lt;TouchableOpacity style={styles.attachmentOptionButton} onPress={pickDocument}&gt;&#10;                            &lt;View style={styles.attachmentOptionIconContainer}&gt;&#10;                                &lt;Ionicons name=&quot;document&quot; size={32} color=&quot;#F59A23&quot;/&gt;&#10;                            &lt;/View&gt;&#10;                            &lt;Text style={styles.attachmentOptionText}&gt;파일&lt;/Text&gt;&#10;                        &lt;/TouchableOpacity&gt;&#10;                    &lt;/View&gt;&#10;                &lt;/View&gt;&#10;            &lt;/Modal&gt;&#10;            {renderSideMenu()}&#10;        &lt;/KeyboardAvoidingView&gt;&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="import {ThemedText} from '@/components/ThemedText';&#10;import {ThemedView} from '@/components/ThemedView';&#10;import styles from '@/constants/style';&#10;import {Ionicons} from '@expo/vector-icons';&#10;import {useBottomTabBarHeight} from '@react-navigation/bottom-tabs';&#10;import {BlurView} from 'expo-blur';&#10;import * as DocumentPicker from 'expo-document-picker';&#10;import * as Haptics from 'expo-haptics';&#10;import {Image} from 'expo-image';&#10;import * as ImagePicker from 'expo-image-picker';&#10;import {useEffect, useRef, useState} from 'react';&#10;import {&#10;    Alert,&#10;    Animated,&#10;    Dimensions,&#10;    FlatList,&#10;    KeyboardAvoidingView,&#10;    Modal,&#10;    Platform,&#10;    Text,&#10;    TextInput,&#10;    TouchableOpacity,&#10;    TouchableWithoutFeedback,&#10;    View&#10;} from 'react-native';&#10;import {router} from 'expo-router';&#10;&#10;const {width: SCREEN_WIDTH} = Dimensions.get('window');&#10;&#10;interface AttachedFile {&#10;    id: string;&#10;    uri: string;&#10;    name: string;&#10;    type: 'image' | 'document';&#10;    size: number;&#10;    mimeType: string;&#10;}&#10;&#10;interface Message {&#10;    id: string;&#10;    text: string;&#10;    timestamp: Date;&#10;    isUser: boolean;&#10;    sender: 'You' | 'Verdora';&#10;    attachedFile?: AttachedFile;&#10;}&#10;&#10;export default function ChatScreen() {&#10;    const tabBarHeight = useBottomTabBarHeight();&#10;    const [messages, setMessages] = useState&lt;Message[]&gt;([&#10;        {&#10;            id: '1',&#10;            text: '안녕하세요! 저는 Verdora입니다. 무엇을 도와드릴까요? ',&#10;            timestamp: new Date(),&#10;            isUser: false,&#10;            sender: 'Verdora',&#10;        },&#10;    ]);&#10;    const [inputText, setInputText] = useState('');&#10;    const [attachedFile, setAttachedFile] = useState&lt;AttachedFile | null&gt;(null);&#10;    const [attachmentModalVisible, setAttachmentModalVisible] = useState(false);&#10;&#10;    const flatListRef = useRef&lt;FlatList&lt;Message&gt;&gt;(null);&#10;&#10;    useEffect(() =&gt; {&#10;        const timer = setTimeout(() =&gt; flatListRef.current?.scrollToEnd({animated: true}), 100);&#10;        return () =&gt; clearTimeout(timer); // 메모리 누수를 방지하기 위해 타이머 정리&#10;    }, [messages]);&#10;&#10;    const [isMenuVisible, setMenuVisible] = useState(false);&#10;    const slideAnim = useRef(new Animated.Value(SCREEN_WIDTH)).current;&#10;&#10;    /**&#10;     * 사이드 메뉴를 여는 함수&#10;     * 메뉴 표시 상태를 true로 설정하고 슬라이드 애니메이션을 실행합니다&#10;     */&#10;    const openMenu = () =&gt; {&#10;        setMenuVisible(true);&#10;        Animated.timing(slideAnim, {&#10;            toValue: 0,&#10;            duration: 250,&#10;            useNativeDriver: true,&#10;        }).start();&#10;    };&#10;&#10;    /**&#10;     * 사이드 메뉴를 닫는 함수&#10;     * 슬라이드 애니메이션 후 메뉴 표시 상태를 false로 설정합니다&#10;     */&#10;    const closeMenu = () =&gt; {&#10;        Animated.timing(slideAnim, {&#10;            toValue: SCREEN_WIDTH,&#10;            duration: 250,&#10;            useNativeDriver: true,&#10;        }).start(() =&gt; setMenuVisible(false));&#10;    };&#10;&#10;    /**&#10;     * Verdora AI의 응답을 생성하는 함수&#10;     * @param msg - 사용자 메시지&#10;     * @param hasFile - 파일 첨부 여부&#10;     * @returns 생성된 응답 문자열&#10;     */&#10;    const getVerdoraResponse = (msg: string, hasFile = false): string =&gt; {&#10;        if (hasFile) {&#10;            const fileResponses = [&#10;                '파일을 확인했습니다! 흥미로운 내용이네요.',&#10;                '첨부해주신 파일 감사합니다. 어떤 도움이 필요하신가요?',&#10;                '파일을 잘 받았습니다! 이것에 대해 더 자세히 알려주세요.',&#10;                '좋은 자료네요! 이와 관련해서 궁금한 점이 있으시면 언제든 물어보세요.',&#10;            ];&#10;            return fileResponses[Math.floor(Math.random() * fileResponses.length)];&#10;        }&#10;        const responses = [&#10;            '흥미로운 질문이네요! 더 자세히 설명해주시겠어요?',&#10;            '네, 이해했습니다. 다른 궁금한 것이 있으신가요?',&#10;            '좋은 생각이에요! 어떻게 도와드릴까요?',&#10;            '그렇군요! 더 많은 정보를 원하시면 언제든 말씀해주세요.',&#10;            '정말 재미있는 주제네요. 계속 이야기해보아요!',&#10;            '감사합니다! 다른 도움이 필요하시면 알려주세요.',&#10;            '네, 알겠습니다. 또 다른 질문이 있으신가요?',&#10;        ];&#10;        if (msg.includes('안녕') || msg.includes('hello')) return '안녕하세요! 좋은 하루 보내고 계신가요? ';&#10;        if (msg.includes('고마워') || msg.includes('감사')) return '천만에요! 언제든지 도와드릴게요. ';&#10;        if (msg.includes('이름') || msg.includes('누구')) return '저는 Verdora예요! AI 어시스턴트로서 여러분을 도와드리고 있어요. ✨';&#10;        return responses[Math.floor(Math.random() * responses.length)];&#10;    };&#10;&#10;    /**&#10;     * 메시지를 전송하는 함수&#10;     * 사용자 메시지를 추가하고 1초 후 AI 응답을 생성합니다&#10;     */&#10;    const sendMessage = async () =&gt; {&#10;        if (inputText.trim() || attachedFile) {&#10;            await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);&#10;            setMessages(prev =&gt; [&#10;                ...prev,&#10;                {&#10;                    id: Date.now().toString(),&#10;                    text: inputText.trim() || (attachedFile ? '파일을 첨부했습니다.' : ''),&#10;                    timestamp: new Date(),&#10;                    isUser: true,&#10;                    sender: 'You',&#10;                    attachedFile: attachedFile || undefined,&#10;                }&#10;            ]);&#10;            const msg = inputText.trim();&#10;            const hasFile = !!attachedFile;&#10;            setInputText('');&#10;            setAttachedFile(null);&#10;            setTimeout(async () =&gt; {&#10;                await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);&#10;                setMessages(prev =&gt; [&#10;                    ...prev,&#10;                    {&#10;                        id: (Date.now() + 1).toString(),&#10;                        text: getVerdoraResponse(msg, hasFile),&#10;                        timestamp: new Date(),&#10;                        isUser: false,&#10;                        sender: 'Verdora',&#10;                    }&#10;                ]);&#10;            }, 1000);&#10;        }&#10;    };&#10;&#10;    /**&#10;     * 파일 선택 결과를 처리하는 함수&#10;     * @param result - ImagePicker 또는 DocumentPicker의 결과&#10;     * @param type - 파일 타입 ('image' 또는 'document')&#10;     */&#10;    const handleFileSelection = async (result: any, type: 'image' | 'document') =&gt; {&#10;        if (!result.canceled &amp;&amp; result.assets?.length) {&#10;            const asset = result.assets[0];&#10;            if (type === 'image' || ['.txt', '.md', '.pdf'].some(ext =&gt; asset.uri.endsWith(ext))) {&#10;                setAttachedFile({&#10;                    id: Date.now().toString(),&#10;                    uri: asset.uri,&#10;                    name: asset.fileName ?? (type === 'image' ? 'image.jpg' : 'document'),&#10;                    type,&#10;                    size: asset.fileSize ?? 0,&#10;                    mimeType: asset.type ?? (type === 'image' ? 'image/jpeg' : 'application/octet-stream'),&#10;                });&#10;            } else {&#10;                console.warn('Only .txt, .md, .pdf files are allowed.');&#10;            }&#10;        }&#10;    };&#10;&#10;    /**&#10;     * 카메라로 사진을 촬영하는 함수&#10;     * 첨부 모달을 닫고 카메라를 실행합니다&#10;     */&#10;    const pickCamera = async () =&gt; {&#10;        setAttachmentModalVisible(false);&#10;        const result = await ImagePicker.launchCameraAsync({&#10;            mediaTypes: ImagePicker.MediaTypeOptions.Images,&#10;            quality: 0.8&#10;        });&#10;        await handleFileSelection(result, 'image');&#10;    };&#10;    &#10;    /**&#10;     * 갤러리에서 이미지를 선택하는 함수&#10;     * 첨부 모달을 닫고 이미지 라이브러리를 실행합니다&#10;     */&#10;    const pickGallery = async () =&gt; {&#10;        setAttachmentModalVisible(false);&#10;        const result = await ImagePicker.launchImageLibraryAsync({&#10;            mediaTypes: ImagePicker.MediaTypeOptions.Images,&#10;            quality: 0.8&#10;        });&#10;        await handleFileSelection(result, 'image');&#10;    };&#10;&#10;    /**&#10;     * 문서 파일을 선택하는 함수&#10;     * 첨부 모달을 닫고 문서 선택기를 실행합니다&#10;     */&#10;    const pickDocument = async () =&gt; {&#10;        setAttachmentModalVisible(false);&#10;        const result = await DocumentPicker.getDocumentAsync({copyToCacheDirectory: true});&#10;        await handleFileSelection(result, 'document');&#10;    };&#10;&#10;    /**&#10;     * 첨부된 파일을 제거하는 함수&#10;     * 햅틱 피드백과 함께 첨부 파일을 null로 설정합니다&#10;     */&#10;    const removeFile = async () =&gt; {&#10;        await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);&#10;        setAttachedFile(null);&#10;    };&#10;&#10;    /**&#10;     * 파일 크기를 사람이 읽기 쉬운 형태로 변환하는 함수&#10;     * @param bytes - 바이트 단위의 파일 크기&#10;     * @returns 변환된 크기 문자열 (예: &quot;1.5 MB&quot;)&#10;     */&#10;    const formatSize = (bytes: number): string =&gt; {&#10;        if (!bytes) return '0 Bytes';&#10;        const k = 1024, sizes = ['Bytes', 'KB', 'MB', 'GB'];&#10;        const i = Math.floor(Math.log(bytes) / Math.log(k));&#10;        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];&#10;    };&#10;&#10;    /**&#10;     * 앱 사용법 가이드를 표시하는 함수&#10;     * 햅틱 피드백과 함께 사용법 알림을 표시합니다&#10;     */&#10;    const showGuide = async () =&gt; {&#10;        await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);&#10;        Alert.alert('사용법', '• Verdora와 자유롭게 대화하세요\n• 질문을 입력하고 전송 버튼을 누르세요\n• + 버튼으로 파일을 첨부할 수 있습니다\n• AI가 자동으로 응답해드립니다', [{text: '확인'}]);&#10;    };&#10;&#10;    /**&#10;     * 메뉴 버튼 클릭을 처리하는 함수&#10;     * 햅틱 피드백과 함께 메뉴를 엽니다&#10;     */&#10;    const handleMenuPress = async () =&gt; {&#10;        await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);&#10;        openMenu();&#10;    };&#10;&#10;    /**&#10;     * 메뉴 항목 클릭을 처리하는 함수&#10;     * @param key - 클릭된 메뉴 항목의 키&#10;     */&#10;    const handleMenuItemPress = (key: string) =&gt; {&#10;        closeMenu();&#10;        setTimeout(() =&gt; {&#10;            switch (key) {&#10;                case 'country':&#10;                    router.push('/countrysettings');&#10;                    break;&#10;                case 'language':&#10;                    Alert.alert('알림', '언어 설정 기능은 준비 중입니다.');&#10;                    break;&#10;                case 'travel':&#10;                    Alert.alert('알림', '타국 여행시 주의점 안내 기능은 준비 중입니다.');&#10;                    break;&#10;                case 'cases':&#10;                    Alert.alert('알림', '관련 사례 보기 기능은 준비 중입니다.');&#10;                    break;&#10;                case 'delete':&#10;                    Alert.alert(&#10;                        '정말 삭제하시겠습니까?',&#10;                        '모든 대화 내용이 사라지며, 복구할 수 없습니다.',&#10;                        [&#10;                            {&#10;                                text: '삭제',&#10;                                style: 'destructive',&#10;                                onPress: async () =&gt; {&#10;                                    await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning);&#10;                                    setMessages([{&#10;                                        id: '1',&#10;                                        text: '안녕하세요! 저는 Verdora입니다. 무엇을 도와드릴까요? ',&#10;                                        timestamp: new Date(),&#10;                                        isUser: false,&#10;                                        sender: 'Verdora',&#10;                                    }]);&#10;                                },&#10;                            },&#10;                            {text: '취소', style: 'cancel'},&#10;                        ]&#10;                    );&#10;                    break;&#10;            }&#10;        }, 250);&#10;    };&#10;&#10;    /**&#10;     * 사이드 메뉴를 렌더링하는 함수&#10;     * @returns 사이드 메뉴 JSX 컴포넌트&#10;     */&#10;    const renderSideMenu = () =&gt; {&#10;        const menuItems = [&#10;            {key: 'country', icon: 'globe-outline', text: '나라 설정'},&#10;            {key: 'language', icon: 'language-outline', text: '언어 설정'},&#10;            {key: 'travel', icon: 'alert-circle-outline', text: '타국 여행시 주의점'},&#10;            {key: 'cases', icon: 'book-outline', text: '관련 사례'},&#10;        ];&#10;        return (&#10;            &lt;Modal transparent visible={isMenuVisible} onRequestClose={closeMenu} animationType=&quot;fade&quot;&gt;&#10;                &lt;TouchableWithoutFeedback onPress={closeMenu}&gt;&#10;                    &lt;View style={styles.menuBackdrop}&gt;&#10;                        &lt;Animated.View style={[styles.menuDrawer, {transform: [{translateX: slideAnim}]}]}&gt;&#10;                            &lt;TouchableWithoutFeedback&gt;&#10;                                &lt;ThemedView style={{flex: 1}}&gt;&#10;                                    &lt;View style={styles.menuHeaderContainer}&gt;&#10;                                        &lt;View style={styles.logo}&gt;&#10;                                            &lt;Image style={styles.logoSize}&#10;                                                   source={require('@/assets/images/icon.png')}/&gt;&#10;                                        &lt;/View&gt;&#10;                                        &lt;ThemedText style={styles.menuHeaderTitle}&gt;Verdora&lt;/ThemedText&gt;&#10;                                    &lt;/View&gt;&#10;                                    &lt;View style={styles.menuSeparator}/&gt;&#10;                                    {menuItems.map(item =&gt; (&#10;                                        &lt;TouchableOpacity key={item.key} style={styles.menuItem}&#10;                                                          onPress={() =&gt; handleMenuItemPress(item.key)}&gt;&#10;                                            &lt;Ionicons name={item.icon as any} size={22} color=&quot;#555&quot;&#10;                                                      style={styles.menuItemIcon}/&gt;&#10;                                            &lt;ThemedText style={styles.menuItemText}&gt;{item.text}&lt;/ThemedText&gt;&#10;                                        &lt;/TouchableOpacity&gt;&#10;                                    ))}&#10;                                    &lt;View style={styles.menuFooter}&gt;&#10;                                        &lt;View style={styles.menuSeparator}/&gt;&#10;                                        &lt;TouchableOpacity style={styles.menuItem}&#10;                                                          onPress={() =&gt; handleMenuItemPress('delete')}&gt;&#10;                                            &lt;Ionicons name=&quot;trash-outline&quot; size={22} color=&quot;#ff4444&quot;&#10;                                                      style={styles.menuItemIcon}/&gt;&#10;                                            &lt;ThemedText style={[styles.menuItemText, {color: '#ff4444'}]}&gt;채팅 기록&#10;                                                삭제&lt;/ThemedText&gt;&#10;                                        &lt;/TouchableOpacity&gt;&#10;                                    &lt;/View&gt;&#10;                                &lt;/ThemedView&gt;&#10;                            &lt;/TouchableWithoutFeedback&gt;&#10;                        &lt;/Animated.View&gt;&#10;                    &lt;/View&gt;&#10;                &lt;/TouchableWithoutFeedback&gt;&#10;            &lt;/Modal&gt;&#10;        );&#10;    };&#10;&#10;    /**&#10;     * 첨부된 파일을 렌더링하는 함수&#10;     * @param file - 렌더링할 첨부 파일 객체&#10;     * @param inMsg - 메시지 내부에서 렌더링되는지 여부 (기본값: false)&#10;     * @returns 첨부 파일 JSX 컴포넌트&#10;     */&#10;    const renderAttachedFile = (file: AttachedFile, inMsg = false) =&gt; (&#10;        &lt;View style={[styles.attachedFileContainer, inMsg &amp;&amp; styles.attachedFileInMessage]}&gt;&#10;            {file.type === 'image' ? (&#10;                &lt;View style={styles.attachedImageContainer}&gt;&#10;                    &lt;Image source={{uri: file.uri}} style={styles.attachedImage} contentFit=&quot;cover&quot; transition={200}/&gt;&#10;                    {!inMsg &amp;&amp; (&#10;                        &lt;TouchableOpacity style={styles.removeFileButton} onPress={removeFile}&#10;                                          hitSlop={{top: 10, bottom: 10, left: 10, right: 10}}&gt;&#10;                            &lt;Ionicons name=&quot;close-circle&quot; size={20} color=&quot;#ff4444&quot;/&gt;&#10;                        &lt;/TouchableOpacity&gt;&#10;                    )}&#10;                &lt;/View&gt;&#10;            ) : (&#10;                &lt;View style={styles.attachedDocumentContainer}&gt;&#10;                    &lt;View style={styles.documentIconContainer}&gt;&#10;                        &lt;Ionicons name=&quot;document-text&quot; size={24} color=&quot;#666&quot;/&gt;&#10;                    &lt;/View&gt;&#10;                    &lt;View style={styles.documentInfo}&gt;&#10;                        &lt;ThemedText style={styles.documentName} numberOfLines={1}&gt;{file.name}&lt;/ThemedText&gt;&#10;                        {file.size &amp;&amp; &lt;ThemedText style={styles.documentSize}&gt;{formatSize(file.size)}&lt;/ThemedText&gt;}&#10;                    &lt;/View&gt;&#10;                    {!inMsg &amp;&amp; (&#10;                        &lt;TouchableOpacity style={styles.removeFileButton} onPress={removeFile}&#10;                                          hitSlop={{top: 10, bottom: 10, left: 10, right: 10}}&gt;&#10;                            &lt;Ionicons name=&quot;close-circle&quot; size={20} color=&quot;#ff4444&quot;/&gt;&#10;                        &lt;/TouchableOpacity&gt;&#10;                    )}&#10;                &lt;/View&gt;&#10;            )}&#10;        &lt;/View&gt;&#10;    );&#10;&#10;    /**&#10;     * 개별 메시지를 렌더링하는 함수&#10;     * @param item - 렌더링할 메시지 객체&#10;     * @returns 메시지 JSX 컴포넌트&#10;     */&#10;    const renderMessage = ({item}: { item: Message }) =&gt; (&#10;        &lt;View style={[&#10;            styles.messageWrapper,&#10;            item.isUser ? styles.userMessageWrapper : styles.aiMessageWrapper&#10;        ]}&gt;&#10;            {!item.isUser &amp;&amp; (&#10;                &lt;View style={styles.aiProfileContainer}&gt;&#10;                    &lt;View style={styles.profileImageContainer}&gt;&#10;                        &lt;View style={styles.profileImagePlaceholder}&gt;&#10;                            &lt;Image style={styles.logoSize} source={require('@/assets/images/icon.png')}/&gt;&#10;&#10;                        &lt;/View&gt;&#10;                    &lt;/View&gt;&#10;                    &lt;ThemedText style={styles.senderName}&gt;Verdora&lt;/ThemedText&gt;&#10;                &lt;/View&gt;&#10;            )}&#10;            &lt;View style={[&#10;                styles.messageContainer,&#10;                item.isUser ? styles.userMessage : styles.otherMessage&#10;            ]}&gt;&#10;                {item.attachedFile &amp;&amp; renderAttachedFile(item.attachedFile, true)}&#10;                {item.text &amp;&amp; (&#10;                    &lt;ThemedText style={[&#10;                        styles.messageText,&#10;                        item.isUser ? styles.userMessageText : styles.otherMessageText,&#10;                        item.attachedFile &amp;&amp; styles.messageTextWithFile&#10;                    ]}&gt;&#10;                        {item.text}&#10;                    &lt;/ThemedText&gt;&#10;                )}&#10;                &lt;ThemedText style={[&#10;                    styles.timestamp,&#10;                    item.isUser ? styles.userTimestamp : styles.aiTimestamp&#10;                ]}&gt;&#10;                    {item.timestamp.toLocaleTimeString('ko-KR', {hour: '2-digit', minute: '2-digit'})}&#10;                &lt;/ThemedText&gt;&#10;            &lt;/View&gt;&#10;        &lt;/View&gt;&#10;    );&#10;&#10;    return (&#10;        &lt;KeyboardAvoidingView&#10;            style={styles.container}&#10;            behavior={Platform.OS === 'ios' ? 'padding' : 'height'}&#10;            keyboardVerticalOffset={Platform.OS === 'ios' ? tabBarHeight : 0}&#10;        &gt;&#10;            &lt;BlurView intensity={0} tint=&quot;light&quot; style={styles.header}&gt;&#10;                &lt;View style={styles.headerContent}&gt;&#10;                    &lt;View style={styles.logoContainer}&gt;&#10;                        &lt;View style={styles.logo}&gt;&#10;                            &lt;Image style={styles.logoSize} source={require('@/assets/images/icon.png')}/&gt;&#10;&#10;                        &lt;/View&gt;&#10;                        &lt;ThemedText style={styles.appName}&gt;Verdora&lt;/ThemedText&gt;&#10;                    &lt;/View&gt;&#10;                    &lt;View style={styles.rightButtons}&gt;&#10;                        &lt;TouchableOpacity style={styles.guideButton} onPress={showGuide}&gt;&#10;                            &lt;ThemedText style={styles.guideButtonText}&gt;사용법&lt;/ThemedText&gt;&#10;                        &lt;/TouchableOpacity&gt;&#10;                        &lt;TouchableOpacity style={styles.hamburgerButton} onPress={handleMenuPress}&gt;&#10;                            &lt;Ionicons name=&quot;menu&quot; size={24} color=&quot;#fff&quot;/&gt;&#10;                        &lt;/TouchableOpacity&gt;&#10;                    &lt;/View&gt;&#10;                &lt;/View&gt;&#10;            &lt;/BlurView&gt;&#10;            &lt;FlatList&#10;                ref={flatListRef}&#10;                data={messages}&#10;                renderItem={renderMessage}&#10;                keyExtractor={(item) =&gt; item.id}&#10;                style={styles.messagesList}&#10;                contentContainerStyle={styles.messagesContainer}&#10;                showsVerticalScrollIndicator={false}&#10;                keyboardShouldPersistTaps=&quot;handled&quot;&#10;            /&gt;&#10;            {attachedFile &amp;&amp; (&#10;                &lt;BlurView intensity={95} tint=&quot;light&quot; style={styles.attachmentPreview}&gt;&#10;                    {renderAttachedFile(attachedFile)}&#10;                &lt;/BlurView&gt;&#10;            )}&#10;            &lt;ThemedView style={[styles.inputContainer]}&gt;&#10;                &lt;TouchableOpacity style={styles.attachButton} onPress={() =&gt; setAttachmentModalVisible(true)}&#10;                                  hitSlop={{top: 5, bottom: 5, left: 5, right: 5}}&gt;&#10;                    &lt;Ionicons name=&quot;add&quot; size={24} color=&quot;#F59A23&quot;/&gt;&#10;                &lt;/TouchableOpacity&gt;&#10;                &lt;TextInput&#10;                    style={styles.textInput}&#10;                    value={inputText}&#10;                    onChangeText={setInputText}&#10;                    placeholder=&quot;Verdora에게 메시지를 보내세요...&quot;&#10;                    placeholderTextColor=&quot;#999&quot;&#10;                    multiline&#10;                    maxLength={1000}&#10;                    returnKeyType=&quot;send&quot;&#10;                /&gt;&#10;                &lt;TouchableOpacity&#10;                    style={[styles.sendButton, {opacity: (inputText.trim() || attachedFile) ? 1 : 0.5}]}&#10;                    onPress={sendMessage}&#10;                    disabled={!inputText.trim() &amp;&amp; !attachedFile}&#10;                    hitSlop={{top: 5, bottom: 5, left: 5, right: 5}}&#10;                &gt;&#10;                    &lt;Ionicons name=&quot;send&quot; size={20} color=&quot;#fff&quot;/&gt;&#10;                &lt;/TouchableOpacity&gt;&#10;            &lt;/ThemedView&gt;&#10;            &lt;Modal&#10;                visible={attachmentModalVisible}&#10;                animationType=&quot;slide&quot;&#10;                transparent&#10;                statusBarTranslucent&#10;                onRequestClose={() =&gt; setAttachmentModalVisible(false)}&#10;            &gt;&#10;                &lt;TouchableWithoutFeedback onPress={() =&gt; setAttachmentModalVisible(false)}&gt;&#10;                    &lt;View style={styles.attachmentModalBackdrop}/&gt;&#10;                &lt;/TouchableWithoutFeedback&gt;&#10;                &lt;View style={styles.attachmentModalContainer}&gt;&#10;                    &lt;Text style={styles.attachmentModalTitle}&gt;첨부파일 선택&lt;/Text&gt;&#10;                    &lt;View style={styles.attachmentOptionsWrapper}&gt;&#10;                        &lt;TouchableOpacity style={styles.attachmentOptionButton} onPress={pickCamera}&gt;&#10;                            &lt;View style={styles.attachmentOptionIconContainer}&gt;&#10;                                &lt;Ionicons name=&quot;camera&quot; size={32} color=&quot;#F59A23&quot;/&gt;&#10;                            &lt;/View&gt;&#10;                            &lt;Text style={styles.attachmentOptionText}&gt;카메라&lt;/Text&gt;&#10;                        &lt;/TouchableOpacity&gt;&#10;                        &lt;TouchableOpacity style={styles.attachmentOptionButton} onPress={pickGallery}&gt;&#10;                            &lt;View style={styles.attachmentOptionIconContainer}&gt;&#10;                                &lt;Ionicons name=&quot;image&quot; size={32} color=&quot;#F59A23&quot;/&gt;&#10;                            &lt;/View&gt;&#10;                            &lt;Text style={styles.attachmentOptionText}&gt;갤러리&lt;/Text&gt;&#10;                        &lt;/TouchableOpacity&gt;&#10;                        &lt;TouchableOpacity style={styles.attachmentOptionButton} onPress={pickDocument}&gt;&#10;                            &lt;View style={styles.attachmentOptionIconContainer}&gt;&#10;                                &lt;Ionicons name=&quot;document&quot; size={32} color=&quot;#F59A23&quot;/&gt;&#10;                            &lt;/View&gt;&#10;                            &lt;Text style={styles.attachmentOptionText}&gt;파일&lt;/Text&gt;&#10;                        &lt;/TouchableOpacity&gt;&#10;                    &lt;/View&gt;&#10;                &lt;/View&gt;&#10;            &lt;/Modal&gt;&#10;            {renderSideMenu()}&#10;        &lt;/KeyboardAvoidingView&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>